

# JavaScript五大设计原则-SOLID

> S(Single Responsibility Principle, SRP)-单一职责原则- 一个程序只做好一件事；如果功能过于复杂就拆分开，每个部分保持独立；
>
> O(Open Closed Principle, OCP)-开放封闭原则- 对扩展开放，对修改封闭；增加需求时，扩展新代码，而非修改已有代码；
>
> L(Liskov Substitution Principe, LSP)-里氏置换原则-子类能覆盖父类；父类能出现的地方子类就能出现；
>
> I(Interface Segregation Principle, ISP)-接口独立原则-保持接口的单一独立，避免出现”胖接口“；js中没有接口（typescript除外），使用少；
>
> D(Dependence Inversion Principle, DIP)-依赖倒置原则-编程依赖抽象接口，不要依赖具体实现；使用方只关注接口而不关注具体类的实现；

![img](https://img-blog.csdnimg.cn/20190923232347563.png)

[图片源自]: https://blog.csdn.net/Ttian6/article/details/101234795
[文章部分内容源自]: http://c.biancheng.net/view/1326.html

# 单一职责原则

### 什么是单一职责原则?

> 就一个类而言，应该仅有一个引起它变化的原因。
> 单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一
> 个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过
> 多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。
> 此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职
> 责耦合在一起的时候，**一个职责发生变化可能会影响到其他职责的实现**，造成意想不到的破坏，
> 这种耦合性得到的是低内聚和脆弱的设计。
> 因此，SRP 原则体现为：**一个对象（方法）只做一件事情**。

### 何时应该分离职责?

> 一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax
>
> 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送
>
> xhr 请求的职责就没有必要分开。
>
> 另一方面，**职责的变化轴线仅当它们确定会发生变化时才具有意义**，即使两个职责已经被耦
>
> 合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的
>
> 时候再进行分离也不迟。

### SRP原则的优缺点

> SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，
>
> 这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他
>
> 的职责。
>
> 但 SRP 原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象
>
> 分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。



# 开放封闭原则

### 什么是开放封闭原则

> 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。

### 开放封闭原则的思想

>当需要改变一个程序的功能或者给这个程序增加新功
>
> 能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

### 如何遵守开放封闭原则

> 利用对象的多态性

> 放置挂钩

> 使用回调函数

### 设计模式之中的开发封闭原则

> 1. 发布订阅模式

发布订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。

> 2. 模板方法模式

模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放封闭原则的。 

> 3. 策略模式

策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。

> 4. 代理模式

拿预加载图片举例，我们现在已有一个给图片设置 src 的函数 myImage，当我们想为它增加图片预加载功能时，一种做法是改动 myImage 函数内部的代码，更好的做法是提供一个代理函数 proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的 myImage 函数，myImage 在这个过程中不需要任何改动。预加载图片的功能和给图片设置 src 的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage 不知晓代理的存在，它可以继续专注于自己的职责——给图片设置 src。

> 5. 责链模式

### 开放封闭原则的相对性

> 在职责链模式代码中，大家也许会产生这个疑问：开放封闭原则要求我们只能通过增加源
>
> 代码的方式扩展程序的功能，而不允许修改源代码。那当我们往职责链中增加一个新的 100 元订
> 
> 单函数节点时，不也必须改动设置链条的代码吗？代码如下：
> 
> order500yuan.setNextSuccessor( order200yuan ).setNextSuccessor( orderNormal ); 
> 
> 变为：
> 
> order500yuan.setNextSuccessor( order200yuan ).setNextSuccessor( order100yuan > ).setNextSuccessor( orderNormal ); 
> 
> 实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间
> 
> 和精力。而且让程序符合开放封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增
> 
> 大代码的复杂度。
> 
> 更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。作
> 
> 为程序员，我们可以做到的有下面两点。
> 
>  **挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。**
> 
>  **在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，**
> 
> **修改它提供的配置文件，总比修改它的源代码来得简单。** 

# 最少知识原则(迪米特法则)

> 最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这
>
> 里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

### 减少对象之间的联系

单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越

多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相

互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。在程序中，对象

的“朋友”太多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的故事

时有发生。

最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不

必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对

象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三

者对象来转发这些请求。

### 设计模式中的最少知识原则

最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式，下面我们分别进行

介绍。

> 中介者模式

在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢

绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所

有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。

中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通

过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象

即可。

> 外观模式

我们在第二部分没有提到外观模式，是因为外观模式在 JavaScript 中的使用场景并不多。外

观模式主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个

接口使子系统更加容易使用。

外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高

层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过

请求外观接口来达到访问子系统的目的。但在一段使用了外观模式的程序中，请求外观并不是强

制的。如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统。 

拿全自动洗衣机的一键洗衣按钮举例，这个一键洗衣按钮就是一个外观。如果是老式洗衣机，

客户要手动选择浸泡、洗衣、漂洗、脱水这 4 个步骤。如果这种洗衣机被淘汰了，新式洗衣机的

漂洗方式发生了改变，那我们还得学习新的漂洗方式。而全自动洗衣机的好处很明显，不管洗衣

机内部如何进化，客户要操作的，始终只是一个一键洗衣的按钮。这个按钮就是为一组子系统所

创建的外观。但如果一键洗衣程序设定的默认漂洗时间是 20 分钟，而客户希望这个漂洗时间是

30 分钟，那么客户自然可以选择越过一键洗衣程序，自己手动来控制这些“子系统”运转。 

外观模式容易跟普通的封装实现混淆。这两者都封装了一些事物，但外观模式的关键是定义

一个高层接口去封装一组“子系统”。子系统在 C++或者 Java 中指的是一组类的集合，这些类相

互协作可以组成系统中一个相对独立的部分。在 JavaScript 中我们通常不会过多地考虑“类”，如

果将外观模式映射到 JavaScript 中，这个子系统至少应该指的是一组函数的集合。

最简单的外观模式应该是类似下面的代码：

```js
var A = function(){ 
 a1(); 
 a2(); 
} 

var B = function(){ 
 b1(); 
 b2(); 
} 

var facade = function(){ 
 A(); 
 B(); 
} 

facade(); 
```

许多 JavaScript 设计模式的图书或者文章喜欢把 jQuery 的$.ajax 函数当作外观模式的实现，

这是不合适的。如果$.ajax 函数属于外观模式，那几乎所有的函数都可以被称为“外观模式”。

问题是我们根本没有办法越过$.ajax“外观”去直接使用该函数中的某一段语句。

现在再来看看外观模式和最少知识原则之间的关系。外观模式的作用主要有两点。

1. 为一组子系统提供一个简单便利的访问入口。
2. 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。

从第二点来，外观模式是符合最少知识原则的。比如全自动洗衣机的一键洗衣按钮，隔开了

客户和浸泡、洗衣、漂洗、脱水这些子系统的直接联系，客户不用去了解这些子系统的具体实现。

假设我们在编写这个老式洗衣机的程序，客户至少要和浸泡、洗衣、漂洗、脱水这 4 个子系

统打交道。如果其中的一个子系统发生了改变，那么客户的调用代码就得发生改变。而通过外观

将客户和这些子系统隔开之后，如果修改子系统内部，只要外观不变，就不会影响客户的调用。

同样，对外观的修改也不会影响到子系统，它们可以分别变化而互不影响。

### 封装在最少知识原则中的体现

封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细

节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引

用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的

范围之内。

> 同时，封装也用来限制变量的作用域。在 JavaScript 中对变量作用域的规定是：
>
> 变量在全局声明，或者在代码的任何位置隐式申明（不用 var），则该变量在全局可见；
>
> 变量在函数内显式申明（使用 var），则在函数内可见。 

把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，

变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。

假设我们要编写一个具有缓存效果的计算乘积的函数 function mult (){}，我们需要一个对

象 var cache = {}来保存已经计算过的结果。cache 对象显然只对 mult 有用，把 cache 对象放在

mult 形成的闭包中，显然比把它放在全局作用域更加合适，代码如下：

```js
var mult = (function(){ 

 var cache = {}; 

 return function(){ 

 var args = Array.prototype.join.call( arguments, ',' ); 

 if ( cache[ args ] ){ 

 return cache[ args ]; 

 } 

 var a = 1; 

 for ( var i = 0, l = arguments.length; i < l; i++ ){ 

图灵社区会员 轩辕 专享 尊重版权262 第 19 章 最少知识原则

 a = a * arguments[i]; 

 } 

 return cache[ args ] = a; 

 } 

})(); 

mult( 1, 2, 3 ); // 输出： 6 
```

其实，最少知识原则也叫迪米特法则（Law of Demeter，LoD），“迪米特”这个名字源自 1987

年美国东北大学一个名为“Demeter”的研究项目。

许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但本书参考 *Head First* 

*Design Patterns* 的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因

是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必

须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难

以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，

要根据具体的环境来定。

# 里氏替换原则

### 里氏替换原则的定义

>  **文章来自 :** (http://c.biancheng.net/view/1324.html)

> 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。
>
> **里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。**

### 里氏替换原则的作用

> 里氏替换原则的主要作用如下。
>
> 1. 里氏替换原则是实现开闭原则的重要方式之一。
> 2. 它克服了继承中重写父类造成的可复用性变差的缺点。
> 3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
> 4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。
>

### 里氏替换原则的实现方法

> 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
>
> 根据上述理解，对里氏替换原则的定义可以总结如下：
>
> - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
> - 子类中可以增加自己特有的方法
> - 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
> - 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等
>


通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。

下面以“几维鸟不是鸟”为例来说明里氏替换原则。

【例1】里氏替换原则在“几维鸟不是鸟”实例中的应用。

分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。



![“几维鸟不是鸟”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif)
图1 “几维鸟不是鸟”实例的类图


程序代码如下：

```java
package principle;
public class LSPtest
{
    public static void main(String[] args)
    {
        Bird bird1=new Swallow();
        Bird bird2=new BrownKiwi();
        bird1.setSpeed(120);
        bird2.setSpeed(120);
        System.out.println("如果飞行300公里：");
        try
        {
            System.out.println("燕子将飞行"+bird1.getFlyTime(300)+"小时.");
            System.out.println("几维鸟将飞行"+bird2.getFlyTime(300)+"小时。");
        }
        catch(Exception err)
        {
            System.out.println("发生错误了!");
        }
    }
}
//鸟类
class Bird
{
    double flySpeed;
    public void setSpeed(double speed)
    {
        flySpeed=speed;
    }
    public double getFlyTime(double distance)
    {
        return(distance/flySpeed);
    }
}
//燕子类
class Swallow extends Bird{}
//几维鸟类
class BrownKiwi extends Bird
{
    public void setSpeed(double speed)
    {
           flySpeed=0;
    }
}
```



程序的运行结果如下：

```java
如果飞行300公里：
燕子将飞行2.5小时.
几维鸟将飞行Infinity小时。
```


程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。



![“几维鸟是动物”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311101SN.gif)
图2 “几维鸟是动物”实例的类图



# 接口隔离原则

### 接口隔离原则的定义

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

> 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
>
> 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
>
> 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

### 接口隔离原则的优点

> 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。
>
> 1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
> 2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
> 3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
> 4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
> 5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 接口隔离原则的实现方法

> 在具体应用接口隔离原则时，应该根据以下几个规则来衡量。
>
> - 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
> - 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
> - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
> - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。


下面以学生成绩管理程序为例介绍接口隔离原则的应用。

【例1】学生成绩管理程序。

分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。

![学生成绩管理程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113141Q0X3.gif)
图1 学生成绩管理程序的类图

程序代码如下：

```java
package principle;
public class ISPtest
{
    public static void main(String[] args)
    {
        InputModule input =StuScoreList.getInputModule();
        CountModule count =StuScoreList.getCountModule();
        PrintModule print =StuScoreList.getPrintModule();
        input.insert();
        count.countTotalScore();
        print.printStuInfo();
        //print.delete();
    }
}
//输入模块接口
interface InputModule
{
    void insert();
    void delete();
    void modify();
}
//统计模块接口
interface CountModule
{
    void countTotalScore();
    void countAverage();
}
//打印模块接口
interface PrintModule
{
    void printStuInfo();
    void queryStuInfo();
}
//实现类
class StuScoreList implements InputModule,CountModule,PrintModule
{
    private StuScoreList(){}
    public static InputModule getInputModule()
    {
        return (InputModule)new StuScoreList();
    }
    public static CountModule getCountModule()
    {
        return (CountModule)new StuScoreList();
    }
    public static PrintModule getPrintModule()
    {
        return (PrintModule)new StuScoreList();
    }
    public void insert()
    {
        System.out.println("输入模块的insert()方法被调用！");
    }
    public void delete()
    {
        System.out.println("输入模块的delete()方法被调用！");
    }
    public void modify()
    {
        System.out.println("输入模块的modify()方法被调用！");
    }
    public void countTotalScore()
    {
        System.out.println("统计模块的countTotalScore()方法被调用！");
    }
    public void countAverage()
    {
        System.out.println("统计模块的countAverage()方法被调用！");
    }
    public void printStuInfo()
    {
        System.out.println("打印模块的printStuInfo()方法被调用！");
    }
    public void queryStuInfo()
    {
        System.out.println("打印模块的queryStuInfo()方法被调用！");
    }
}
```


程序的运行结果如下：

```java
输入模块的insert()方法被调用！
统计模块的countTotalScore()方法被调用！
打印模块的printStuInfo()方法被调用！
```

# 依赖倒置原则

### 依赖倒置原则的定义

依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 [C++](http://c.biancheng.net/cplus/) Report 上发表的文章。

**依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象**（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。**其核心思想是：要面向接口编程，不要面向实现编程。**

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

### 依赖、倒置原则的作用

> 依赖倒置原则的主要作用如下。
>
> - 依赖倒置原则可以降低类间的耦合性。
> - 依赖倒置原则可以提高系统的稳定性。
> - 依赖倒置原则可以减少并行开发引起的风险。
> - 依赖倒置原则可以提高代码的可读性和可维护性。

### 依赖倒置原则的实现方法

> 依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
>
> 1. 每个类尽量提供接口或抽象类，或者两者都具备。
> 2. 变量的声明类型尽量是接口或者是抽象类。
> 3. 任何类都不应该从具体类派生。
> 4. 使用继承时尽量遵循里氏替换原则。


下面以“顾客购物程序”为例来说明依赖倒置原则的应用。

【例1】依赖倒置原则在“顾客购物程序”中的应用。

分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：

```java
class Customer
{
    public void shopping(ShaoguanShop shop)
    {
        //购物
        System.out.println（shop.sell());
    }
}
```


但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：

```java
class Customer
{
    public void shopping(WuyuanShop shop)
    {
        //购物
        System.out.println(shop.sell());
    }
}
```


顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：

```java
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell());
    }
}
```


这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。



![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)
图1 顾客购物程序的类图


程序代码如下：

```java
package principle;
public class DIPtest
{
    public static void main(String[] args)
    {
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
//商店
interface Shop
{
    public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
    public String sell()
    {
        return "韶关土特产：香菇、木耳……"; 
    } 
}
//婺源网店
class WuyuanShop implements Shop
{
    public String sell()
    {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
//顾客
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell()); 
    }
}
```


程序的运行结果如下：

```
顾客购买以下商品：
韶关土特产：香菇、木耳……
婺源土特产：绿茶、酒糟鱼……
```

# 接口和面向接口编程

- 我们经常说一个库或者模块对外提供了某某 API 接口。通过主动暴露的接口来通信，可以隐

藏软件系统内部的工作细节。这也是我们最熟悉的第一种接口含义。

- 第二种接口是一些语言提供的关键字，比如 Java 的 interface。interface 关键字可以产生一

个完全抽象的类。这个完全抽象的类用来表示一种契约，专门负责建立类与类之间的联系。

- 第三种接口即是我们谈论的“面向接口编程”中的接口，接口的含义在这里体现得更为抽象。

用《设计模式》中的话说就是：

**接口是对象能响应的请求的集合。**

<!--详细内容见JavaScript设计模式第21章接口和面向接口编程-->

